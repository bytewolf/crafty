#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/mimi.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI';
  package App::mimi;use strict;use warnings;our$VERSION='0.03';use Carp qw(croak);use File::Spec;use File::Basename ();use DBI;use App::mimi::db;use App::mimi::migration;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dsn}=$params{dsn};$self->{schema}=$params{schema};$self->{dry_run}=$params{dry_run};$self->{verbose}=$params{verbose};$self->{migration}=$params{migration};$self->{setup}=$params{setup};$self->{dbh}=$params{dbh};return$self}sub setup {my$self=shift;my$db=$self->_build_db;if ($db->is_prepared){$self->_print("Error: migrations table already exists");return}$self->_print("Creating migrations table");$db->prepare unless$self->_is_dry_run;return$self}sub migrate {my$self=shift;die "Error: Schema directory is required\n" unless$self->{schema}&& -d $self->{schema};if ($self->{setup}){$self->setup}my@schema_files=glob("$self->{schema}/*.sql");die "Error: No schema *.sql files found in '$self->{schema}'\n" unless@schema_files;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if ($last_migration && $last_migration->{status}ne 'success'){$last_migration->{error}||= 'Unknown error';die "Error: Migrations are dirty. " ."Last error was in migration $last_migration->{no}:\n\n" ."    $last_migration->{error}\n" ."After fixing the problem run <fix> command\n"}$self->_print("Found last migration $last_migration->{no}")if$last_migration;my@migrations;for my$file (@schema_files){my ($no,$name)=File::Basename::basename($file)=~ /^(\d+)(.*)$/;next unless$no && $name;$no=int($no);next if$last_migration && $no <= $last_migration->{no};my$sql=App::mimi::migration->new->parse($file);push@migrations,{file=>$file,no=>$no,name=>$name,sql=>$sql }}if (@migrations){my$dbh=$self->{dbh};for my$migration (@migrations){$self->_print("Migrating '$migration->{file}'");my$e;my$last_query='';if (!$self->_is_dry_run){eval {for my$sql (@{$migration->{sql}|| []}){$last_query=$sql;$dbh->do($sql)}}or do {$e=$@;$e =~ s{ at .*? line \d+.$}{}}}$self->_print("Creating migration: $migration->{no}");$db->create_migration(no=>$migration->{no},created=>time,status=>$e ? 'error' : 'success',error=>substr($e,0,255))unless$self->_is_dry_run;die "Error: $e\nQuery: $last_query\n" if$e}}else {$self->_print("Nothing to migrate")}return$self}sub check {my$self=shift;$self->{verbose}=1;my$db=$self->_build_db;if (!$db->is_prepared){$self->_print('Migrations are not installed')}else {my$last_migration=$db->fetch_last_migration;if (!defined$last_migration){$self->_print('No migrations found')}else {$self->_print(sprintf 'Last migration: %d (%s)',$last_migration->{no},$last_migration->{status});if (my$error=$last_migration->{error}){$self->_print("\n" .$error)}}}}sub fix {my$self=shift;my$db=$self->_build_db_prepared;my$last_migration=$db->fetch_last_migration;if (!$last_migration || $last_migration->{status}eq 'success'){$self->_print('Nothing to fix')}else {$self->_print("Fixing migration $last_migration->{no}");$db->fix_last_migration unless$self->_is_dry_run}}sub set {my$self=shift;my$db=$self->_build_db_prepared;$self->_print("Creating migration $self->{migration}");$db->create_migration(no=>$self->{migration},created=>time,status=>'success')unless$self->_is_dry_run}sub _build_db_prepared {my$self=shift;my$db=$self->_build_db;die "Error: Migrations table not found. Run <setup> command first or use --setup flag\n" unless$db->is_prepared;return$db}sub _build_db {my$self=shift;my$dbh=$self->{dbh};if (!$dbh){$dbh=DBI->connect($self->{dsn},'','',{RaiseError=>1,PrintError=>0,PrintWarn=>0});$self->{dbh}=$dbh}return App::mimi::db->new(dbh=>$dbh)}sub _print {my$self=shift;return unless$self->_is_verbose;print 'DRY RUN: ' if$self->_is_dry_run;print @_,"\n"}sub _is_dry_run {$_[0]->{dry_run}}sub _is_verbose {$_[0]->{verbose}|| $_[0]->_is_dry_run}1;
APP_MIMI

$fatpacked{"App/mimi/db.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_DB';
  package App::mimi::db;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{dbh}=$params{dbh}or croak 'dbh required';$self->{columns}=[qw/no created status error/];return$self}sub is_prepared {my$self=shift;local$SIG{__WARN__}=sub {};my$rv;eval {$rv=$self->{dbh}->do('SELECT 1 FROM mimi LIMIT 1')};return unless$rv;return 1}sub prepare {my$self=shift;my$driver=$self->{dbh}->{Driver}->{Name};if ($driver eq 'SQLite'){$self->{dbh}->do(<<'EOF')}elsif ($driver eq 'Pg'){$self->{dbh}->do(<<'EOF')}}sub fix_last_migration {my$self=shift;my$last_migration=$self->fetch_last_migration;return unless$last_migration;$self->{dbh}->do("UPDATE mimi SET status = 'success', error = '' WHERE id=$last_migration->{id}")or die $!;return$self}sub create_migration {my$self=shift;my (%migration)=@_;$migration{created}||= time;my$columns=join ',',keys%migration;my$values=join ',',map {"'$_'"}values%migration;$self->{dbh}->do("INSERT INTO mimi ($columns) VALUES ($values)")or die $!;return$self}sub fetch_last_migration {my$self=shift;my$sth=$self->{dbh}->prepare('SELECT id, no, created, status, error FROM mimi ORDER BY id DESC LIMIT 1');my$rv=$sth->execute or die $!;my$row=$sth->fetchall_arrayref->[0];return unless$row;my$migration={};for (qw/id no created status error/){$migration->{$_}=shift @$row}return$migration}1;
      CREATE TABLE mimi (
          id INTEGER PRIMARY KEY AUTOINCREMENT,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
      CREATE TABLE mimi (
          id serial PRIMARY KEY,
          created INTEGER NOT NULL,
          no INTEGER NOT NULL,
          status VARCHAR(32) NOT NULL,
          error VARCHAR(255)
      );
  EOF
APP_MIMI_DB

$fatpacked{"App/mimi/migration.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_MIMI_MIGRATION';
  package App::mimi::migration;use strict;use warnings;use Carp qw(croak);sub new {my$class=shift;my$self={};bless$self,$class;return$self}sub parse {my$self=shift;my ($file)=@_;my@lines=map {chomp;$_}$self->_slurp($file);my$multiline='';my@sql;my@parts;for my$line (@lines){next if$line =~ m/^(?:--|#)/;push@parts,$line;pos$parts[-1]=0;if ($multiline){if ($parts[-1]=~ m/\G.*?\Q$multiline\E/gc){$multiline=''}else {next}}if ($parts[-1]=~ m/\G.*?(\$.*?\$)/gc){$multiline=$1}if (!$multiline && $parts[-1]=~ s/;$//){push@sql,$self->_join(@parts);@parts=()}}push@sql,$self->_join(@parts)if@parts;@sql=grep {length}map {s/^\s+//;s/\s+$//;$_}@sql;return \@sql}sub _join {my$self=shift;my (@parts)=@_;return join "\n",@parts}sub _slurp {my$self=shift;my ($file)=@_;open my$fh,'<',$file or croak "Can't open file '$file': $!";<$fh>}1;
APP_MIMI_MIGRATION

$fatpacked{"Class/Accessor/Lite.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'CLASS_ACCESSOR_LITE';
  package Class::Accessor::Lite;use strict;our$VERSION='0.08';sub croak {require Carp;Carp::croak(@_)}sub import {shift;my%args=@_;my$pkg=caller(0);my%key_ctor=(rw=>\&_mk_accessors,ro=>\&_mk_ro_accessors,wo=>\&_mk_wo_accessors,);for my$key (sort keys%key_ctor){if (defined$args{$key}){croak("value of the '$key' parameter should be an arrayref")unless ref($args{$key})eq 'ARRAY';$key_ctor{$key}->($pkg,@{$args{$key}})}}_mk_new($pkg)if$args{new};1}sub mk_new_and_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_new($pkg);_mk_accessors($pkg,@properties)}sub mk_new {my$pkg=caller(0);_mk_new($pkg)}sub mk_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_accessors($pkg,@properties)}sub mk_ro_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_ro_accessors($pkg,@properties)}sub mk_wo_accessors {(undef,my@properties)=@_;my$pkg=caller(0);_mk_wo_accessors($pkg,@properties)}sub _mk_new {my$pkg=shift;no strict 'refs';*{$pkg .'::new'}=__m_new($pkg)}sub _mk_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m($n)}}sub _mk_ro_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_ro($pkg,$n)}}sub _mk_wo_accessors {my$pkg=shift;no strict 'refs';for my$n (@_){*{$pkg .'::' .$n}=__m_wo($pkg,$n)}}sub __m_new {my$pkg=shift;no strict 'refs';return sub {my$klass=shift;bless {(@_==1 && ref($_[0])eq 'HASH' ? %{$_[0]}: @_),},$klass}}sub __m {my$n=shift;sub {return $_[0]->{$n}if @_==1;return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}sub __m_ro {my ($pkg,$n)=@_;sub {if (@_==1){return $_[0]->{$n}if @_==1}else {my$caller=caller(0);croak("'$caller' cannot access the value of '$n' on objects of class '$pkg'")}}}sub __m_wo {my ($pkg,$n)=@_;sub {if (@_==1){my$caller=caller(0);croak("'$caller' cannot alter the value of '$n' on objects of class '$pkg'")}else {return $_[0]->{$n}=$_[1]if @_==2;shift->{$n}=\@_}}}1;
CLASS_ACCESSOR_LITE

$fatpacked{"Docopt.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT';
  use 5.008005;use strict;use warnings FATAL=>'all';package Docopt;use Docopt::Util qw(string_partition in serialize defined_or);package Docopt::Pattern;use Docopt::Util qw(defined_or);sub new {my$class=shift;bless [],$class}sub fix {my$self=shift;$self->fix_identities();$self->fix_repeating_arguments();return$self}use Docopt::Util qw(in serialize);sub fix_identities {my ($self,$uniq)=@_;if (!$self->can('children')){return$self}$uniq=defined_or($uniq,$self->flat);for (my$i=0;$i<@{$self->children};$i++){my$child=$self->children->[$i];if (not $child->can('children')){local$Storable::canonical=1;in(serialize($child),[map {serialize($_)}@$uniq])or die;($self->children->[$i],)=grep {serialize($_)eq serialize($child)}@$uniq}else {$child->fix_identities($uniq)}}}use Scalar::Util qw(refaddr);use Docopt::Util qw(repl serialize);sub fix_repeating_arguments {my$self=shift;my$list_count=sub {my ($list,$stuff)=@_;my$n=0;for (@$list){$n++ if serialize($stuff)eq serialize($_)}return$n};my@either=map {$_->children}@{Docopt::transform($self)->children};for my$case (@either){for my$e (grep {$list_count->($case,$_)> 1}@$case){if ($e->isa('Docopt::Argument')|| ($e->isa('Docopt::Option')&& $e->argcount)){if (not defined$e->value){$e->value([])}elsif (ref($e->value)ne 'ARRAY'){$e->value([split /\s+/,$e->value])}}if ($e->isa('Docopt::Command')|| ($e->isa('Docopt::Option')&& $e->argcount==0)){$e->value(0)}}}return$self}package Docopt;use parent qw(Exporter);our@EXPORT=qw(docopt);use List::MoreUtils qw(any);use Scalar::Util qw(blessed refaddr);use Docopt::Util qw(repl pyprint serialize);sub transform {my ($pattern)=@_;my@results;my@groups=[$pattern];while (@groups){my$children=shift@groups;my@parents=qw(Docopt::Required Docopt::Optional Docopt::OptionsShortcut Docopt::Either Docopt::OneOrMore);if (any {in($_,[map {blessed $_}@$children])}@parents){my$child=[grep {in(blessed $_,\@parents)}@$children]->[0];$children=[grep {refaddr($child)ne refaddr($_)}@$children ];if ($child->isa('Docopt::Either')){for (@{$child->children}){push@groups,[$_,@{$children}]}}elsif ($child->isa('Docopt::OneOrMore')){push@groups,[@{$child->children},@{Storable::dclone($child->children)},@$children]}else {push@groups,[@{$child->children},@$children]}}else {push@results,$children}}return Docopt::Either->new([map {Docopt::Required->new($_)}@results])}package Docopt::LeafPattern;use parent -norequire,qw(Docopt::Pattern);use Docopt::Util qw(repl class_name True False is_number);use Class::Accessor::Lite (rw=>[qw(name)],);sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub __repl__ {my$self=shift;sprintf '%s(%s, %s)',class_name($self),repl($self->name),repl($self->value)}sub flat {my ($self,$types)=@_;if (!defined($types)|| $self->isa($types)){return [$self]}else {return []}}sub match {my$self=shift;my@left=@{+shift};my@collected=@{+shift || +[]};my ($pos,$match)=$self->single_match(\@left);unless ($match){return (False,\@left,\@collected)}my@left_=(@left[0..$pos-1],@left[$pos+1..@left-1]);my@same_name=grep {$_->name eq $self->name}@collected;if (is_number($self->value)|| ref($self->value)eq 'ARRAY'){my$increment;if (is_number($self->value)){$increment=1}else {$increment=ref($match->value)eq 'ARRAY' ? $match->value : [$match->value]}unless (@same_name){$match->value($increment);return (True,\@left_,[@collected,$match])}if (ref$same_name[0]->value eq 'ARRAY'){$same_name[0]->value([@{$same_name[0]->value},ref($increment)eq 'ARRAY' ? @$increment : $increment])}else {ref($increment)ne 'ARRAY' or Carp::confess("Invalid addition");$same_name[0]->value($same_name[0]->value + $increment)}return (True,\@left_,\@collected)}return (True,\@left_,[@collected,$match])}package Docopt::BranchPattern;use parent -norequire,qw(Docopt::Pattern);use Carp;use Docopt::Util qw(repl class_name);use Scalar::Util qw(blessed);sub new {my ($class,$children)=@_;Carp::croak("Too much arguments")unless @_==2;Carp::confess "Children must be arrayref: $class, $children" unless ref$children eq 'ARRAY';$children=[map {ref($_)eq 'ARRAY' ? @$_ : $_}@$children];bless {children=>[@$children],},$class}sub children {my$self=shift;return$self->{children}if @_==0;if (@_==1){ref($_[0])eq 'ARRAY' or Carp::confess("Argument must be ArrayRef but: " .$_[0]);$self->{children}=$_[0]}else {Carp::confess("Too much arguments")}}sub __repl__ {my$self=shift;sprintf '%s(%s)',class_name($self),join(', ',map {repl($_)}@{$self->{children}})}sub flat {my$self=shift;my$types=shift;if (defined($types)&& $self->isa($types)){return [$self]}my@ret=map {ref($_)eq 'ARRAY' ? @$_ : $_}map {$_->flat($types)}@{$self->children};return \@ret}package Docopt::Argument;use parent -norequire,qw(Docopt::LeafPattern);sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){return ($n,Docopt::Argument->new($self->name,$pattern->value))}}return (undef,undef)}sub parse {my ($class,$source)=@_;$source =~ /(<\S*?>)/;my$name=$1;$source =~ /\[default: (.*)\]/i;my$value=$1;return$class->new($name,$value)}package Docopt::Command;use parent -norequire,qw(Docopt::Argument);use Class::Accessor::Lite (rw=>[qw(name value)]);use boolean;sub new {my ($class,$name,$value)=@_;bless {name=>$name,value=>$value,},$class}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($pattern->isa(Docopt::Argument::)){if ($pattern->value eq $self->name){return ($n,Docopt::Command->new($self->name,true))}else {last}}}return (undef,undef)}package Docopt::Required;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my$l=$left;my$c=$collected;for my$pattern (@{$self->children}){my$matched;($matched,$l,$c)=$pattern->match($l,$c);unless ($matched){ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref");return (false,$left,$collected)}}ref($c)eq 'ARRAY' or Carp::confess("c is not arrayref: " .join(', ',@{$self->children}));return (true,$l,$c)}package Docopt::Optional;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));my$m;for my$pattern (@{$self->children}){($m,$left,$collected)=$pattern->match($left,$collected)}ref($collected)eq 'ARRAY' or Carp::confess("collected is not arrayref: " .join(', ',@{$self->children}));return (true,$left,$collected)}package Docopt::OptionsShortcut;use parent -norequire,qw(Docopt::Optional);package Docopt::OneOrMore;use parent -norequire,qw(Docopt::BranchPattern);use boolean;use Storable;use Docopt::Util qw(serialize);sub match {my ($self,$left,$collected)=@_;@{$self->children}==1 or die;$collected ||= [];my$l=$left;my$c=$collected;my$l_=undef;my$matched=true;my$times=0;while ($matched){($matched,$l,$c)=$self->children->[0]->match($l,$c);$times++ if$matched;if (serialize(\$l_)eq serialize(\$l)){last}$l_=$l}if ($times >= 1){return (true,$l,$c)}return (false,$left,$collected)}package Docopt::Either;use parent -norequire,qw(Docopt::BranchPattern);use boolean;sub match {my ($self,$left,$collected)=@_;$collected ||= [];my@outcomes;for my$pattern (@{$self->children}){my@outcome=$pattern->match($left,$collected);my$matched=$outcome[0];if ($matched){push@outcomes,\@outcome}}if (@outcomes){my$retval=shift@outcomes;for (@outcomes){if (@{$_->[1]}< @{$retval->[1]}){$retval=$_}}return @$retval}return (false,$left,$collected)}package Docopt::Tokens;use Docopt::Util qw(repl);use Class::Accessor::Lite 0.05 (rw=>[qw(error source)],);sub new {my ($class,$source,$error)=@_;$error ||= 'Docopt::Exceptions::DocoptExit';unless (ref$source){$source=[split /\s+/,$source]}bless {source=>[@$source],error=>$error},$class}sub from_pattern {my ($class,$source)=@_;$source =~ s/([\[\]\(\)\|]|\.\.\.)/ $1 /g;my@source=grep {defined($_)&& length $_ > 0}split /\s+|(\S*<.*?>)/,$source;return Docopt::Tokens->new(\@source,'Docopt::Exceptions::DocoptLanguageError')}sub move {my$self=shift;shift @{$self->{source}}}sub current {my$self=shift;$self->source->[0]}sub __repl__ {my$self=shift;'[' .join(', ',map {repl($_)}@{$self->source}).']'}package Docopt;our$VERSION="0.03";package Docopt::Option;use parent -norequire,qw(Docopt::LeafPattern);use Docopt::Util qw(repl string_strip string_partition defined_or);use Class::Accessor::Lite 0.05 (rw=>[qw(short long argcount)],);sub new {my ($class,$short,$long,$argcount,$value)=@_;if (@_<= 3){$argcount=0}return bless {short=>$short,long=>$long,argcount=>$argcount,value=>!defined($value)&& $argcount ? undef : $value,},$class}sub value {my$self=shift;return$self->{value}if @_==0;if (@_==1){$self->{value}=$_[0]}else {Carp::confess("Too much arguments")}}sub single_match {my ($self,$left)=@_;ref$left eq 'ARRAY' or die;for (my$n=0;$n<@$left;$n++){my$pattern=$left->[$n];if ($self->name eq defined_or($pattern->name,'')){return ($n,$pattern)}}return (undef,undef)}sub name {my$self=shift;if (defined($self->long)&&!ref($self->long)){$self->long}else {$self->short}}sub parse {my ($class,$option_description)=@_;my ($short,$long,$argcount,$value)=(undef,undef,0,undef);my ($options,undef,$description)=string_partition(string_strip($option_description),'  ');$options =~ s/,/ /g;$options =~ s/=/ /g;for my$s (split /\s+/,$options){if ($s =~ /^--/){$long=$s}elsif ($s =~ /^-/){$short=$s}else {$argcount=1}}if ($argcount){if (defined($description)&& $description =~ /\[default: (.*)\]/i){$value=$1}}return$class->new($short,$long,$argcount,$value)}sub __repl__ {my ($self)=@_;sprintf 'Option(%s, %s, %s, %s)',repl($self->{short}),repl($self->{long}),repl($self->{argcount}),repl($self->{value})}package Docopt;use boolean;sub parse_long {my ($tokens,$options)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my ($long,$eq,$value)=string_partition($tokens->move,'=');$long =~ /\A--/ or die;$value=$eq eq '' && $value eq '' ? undef : $value;my@similar=grep {$_->long && $_->long eq $long}@$options;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit' && @similar==0){@similar=grep {$_->long && $_->long =~ /$long/}@$options}my$o;if (@similar > 1){$tokens->error->throw(sprintf '%s is not a unique prefix: %s?',$long,join(', ',map {$_->long}@similar))}elsif (@similar < 1){my$argcount=$eq eq '=' ? 1 : 0;$o=Docopt::Option->new(undef,$long,$argcount);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new(undef,$long,$argcount,$argcount ? $value : true)}}else {$o=Docopt::Option->new($similar[0]->short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value,);if ($o->argcount==0){if (defined$value){$tokens->error->throw(sprintf "%s must not have an argument",$o->long)}}else {if (not defined$value){if ((not defined$tokens->current())|| $tokens->current eq '--'){$tokens->error->throw(sprintf "%s requires argument",$o->long)}$value=$tokens->move}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}return [$o]}sub parse_shorts {my ($tokens,$options)=@_;my$token=$tokens->move;(my$left=$token)=~ s/^-//;my@parsed;while ($left ne ''){my$o;$left =~ s/\A(.)//;my$short='-' .$1;my@similar=grep {defined_or($_->short,'')eq $short}@$options;if (@similar > 1){$tokens->error->throw(sprintf "%s is specified ambiguously %d times",$short,0+@similar)}elsif (@similar < 1){$o=Docopt::Option->new($short,undef,0);push @$options,$o;if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o=Docopt::Option->new($short,undef,0,undef)}}else {$o=Docopt::Option->new($short,$similar[0]->long,$similar[0]->argcount,$similar[0]->value);my$value=undef;if ($o->argcount!=0){if ($left eq ''){if (!defined($tokens->current)|| $tokens->current eq '--'){$tokens->error->throw("$short requires argument")}$value=$tokens->move}else {$value=$left;$left=''}}if ($tokens->error eq 'Docopt::Exceptions::DocoptExit'){$o->value(defined($value)? $value : true)}}push@parsed,$o}return \@parsed}use Docopt::Util qw(repl);sub parse_pattern {my ($source,$options)=@_;my$tokens=Docopt::Tokens->from_pattern($source);my$result=parse_expr($tokens,$options);if (defined$tokens->current()){$tokens->error->throw("unexpected ending: " .repl(join(' ',$tokens)))}return Docopt::Required->new($result)}sub parse_expr {my ($tokens,$options)=@_;my$seq=parse_seq($tokens,$options);if (!defined($tokens->current)|| $tokens->current ne '|'){return$seq}my@result=@$seq > 1 ? Docopt::Required->new($seq): @$seq;while (defined($tokens->current)&& $tokens->current eq '|'){$tokens->move();$seq=parse_seq($tokens,$options);push@result,@$seq > 1 ? Docopt::Required->new($seq): @$seq}return@result > 1 ? [Docopt::Either->new([map {ref($_)eq 'ARRAY' ? @$_ : $_}@result])]: \@result}sub parse_seq {my ($tokens,$options)=@_;my@result;while (not in($tokens->current,[undef,']',')','|'])){my$atom=parse_atom($tokens,$options);if (defined($tokens->current)&& $tokens->current eq '...'){$atom=Docopt::OneOrMore->new($atom);$tokens->move}push@result,$atom}return [map {ref($_)eq 'ARRAY' ? @$_ : $_}@result]}sub parse_atom {my ($tokens,$options)=@_;my$token=$tokens->current();my@result;if ($token eq '(' || $token eq '['){$tokens->move;my ($matching,$pattern)=@{{'('=>[')',Docopt::Required::],'['=>[']',Docopt::Optional::]}->{$token}};my$expr=parse_expr($tokens,$options);my$result=$pattern->new($expr);if (($tokens->move ||'')ne $matching){Docopt::Exceptions::DocoptLanguageError->throw("unmatched '$token'")}return [$result]}elsif ($token eq 'options'){$tokens->move;return [Docopt::OptionsShortcut->new([])]}elsif ($token =~ /^--/ && $token ne '--'){return parse_long($tokens,$options)}elsif ($token =~ /^-/ && ($token ne '-' && $token ne '--')){return parse_shorts($tokens,$options)}elsif (($token =~ /^</ && $token =~ />$/)or $token =~ /\A[A-Z]+\z/){return [Docopt::Argument->new($tokens->move)]}else {return [Docopt::Command->new($tokens->move)]}}sub parse_argv {my ($tokens,$options,$options_first)=@_;ref($options)eq 'ARRAY' or Carp::confess "Options must be arrayref";my@parsed;while (defined$tokens->current()){if ($tokens->current()eq '--'){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}elsif ($tokens->current()=~ /\A--/){push@parsed,@{parse_long($tokens,$options)}}elsif ($tokens->current()=~ /\A-/ && $tokens->current ne '-'){push@parsed,@{parse_shorts($tokens,$options)}}elsif ($options_first){return [@parsed,map {Docopt::Argument->new(undef,$_)}@{$tokens->source}]}else {push@parsed,Docopt::Argument->new(undef,$tokens->move)}}return \@parsed}sub parse_defaults {my ($doc)=@_;my@defaults;for my$s (parse_section('options:',$doc)){(undef,undef,$s)=string_partition($s,':');my@split=split /\n *(-\S+?)/,"\n" .$s;shift@split;my@split2;for (my$i=0;$i<@split;$i+=2){push@split2,$split[$i].defined_or($split[$i+1],'')}for my$s (grep /^-/,@split2){push@defaults,Docopt::Option->parse($s)}}return@defaults}sub parse_section {my ($name,$source)=@_;defined($source)or Carp::confess("Missing source");my@s;while ($source =~ /^([^\n]*${name}[^\n]*\n?(?:[ \t].*?(?:\n|$))*)/img){local $_=$1;s/\A\s+//;s/\s+\z//;push@s,$_}return@s}sub formal_usage {my ($section)=@_;(undef,undef,$section)=string_partition($section,':');my@pu=grep {/\S/}split /\s+/,$section;my$cmd=shift@pu;return '( ' .join(' ',map {$_ eq $cmd ? ') | (' : $_}@pu).' )'}use List::MoreUtils qw(any);sub extras {my ($help,$version,$options,$doc)=@_;if ($help && any {in($_->name,['-h','--help'])&& $_->value}@$options){print$doc ."\n";exit(0)}if ($version && grep {defined($_->name)&& $_->name eq '--version'}@$options){print "$version\n";exit(0)}}sub docopt {@_%2==0 or Carp::confess("You need to pass arguments are hash");my%args=@_;my$doc=delete$args{doc};my$argv=delete$args{argv}|| \@ARGV;my$help=exists($args{help})? delete$args{help}: true;my$version=delete$args{version};my$option_first=delete$args{option_first};if (%args){Carp::confess("Unknown argument passed to docopt(): " .join(", ",keys%args))}if (not defined$doc){require Pod::Usage;open my$fh,'>',\$doc or die $!;my$parser=Pod::Usage->new(USAGE_OPTIONS=>+{});$parser->select('(?:SYNOPSIS|USAGE)\s*');$parser->parse_from_file($0,$fh)}my@usage_sections=parse_section('usage:',$doc);if (@usage_sections==0){Docopt::Exceptions::DocoptLanguageError->throw('"usage:" (case-insensitive) not found.')}if (@usage_sections > 1){Docopt::Exceptions::DocoptLanguageError->throw('More than one "usage:" (case-insensitive).')}$Docopt::Exceptions::DocoptExit::USAGE=$usage_sections[0];my$options=[parse_defaults($doc)];my$pattern=parse_pattern(formal_usage($usage_sections[0]),$options);$argv=parse_argv(Docopt::Tokens->new($argv),$options,$option_first);my$parse_options=$pattern->flat(Docopt::Option::);for my$options_shortcut (@{$pattern->flat(Docopt::OptionsShortcut::)}){my@doc_options=parse_defaults($doc);$options_shortcut->children([grep {!in(serialize($_),[map {serialize($_)}@$parse_options])}@doc_options])}extras($help,$version,$argv,$doc);my ($matched,$left,$collected)=$pattern->fix->match($argv);if ($matched && serialize($left)eq serialize([])){return +{map {$_->name=>$_->value}@{$pattern->flat},@$collected }}Docopt::Exceptions::DocoptExit->throw()}package Docopt::Exception;use overload (q{""}=>'stringify',);sub stringify {my$self=shift;sprintf "[%s] %s",ref$self,$self->{message}|| 'Died'}sub new {my ($class,$message)=@_;bless {message=>$message},$class}sub throw {my ($class,$message)=@_;die$class->new($message)}package Docopt::Exceptions::DocoptLanguageError;use parent -norequire,qw(Docopt::Exception);package Docopt::Exceptions::DocoptExit;use parent -norequire,qw(Docopt::Exception);our$USAGE;sub stringify {my$self=shift;sprintf "%s\n%s\n",$self->{message}|| '',$USAGE}1;
DOCOPT

$fatpacked{"Docopt/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'DOCOPT_UTIL';
  package Docopt::Util;use strict;use warnings;use utf8;use parent qw(Exporter);use boolean;our@EXPORT_OK=qw(repl class_name string_strip string_partition in True False is_number defined_or serialize pyprint);sub True() {true}sub False() {false}use Data::Dumper;use Scalar::Util ();use Storable ();use B;sub pyprint {print Docopt::Util::repl($_[0]),$/}sub serialize($) {local$Storable::canonical=1;return Storable::nfreeze($_[0])}sub is_number {my$value=shift;my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK | B::SVp_NOK)and!($flags & B::SVp_POK);return 0}sub in {my ($val,$patterns)=@_;for (@$patterns){if (defined $_){return 0 if not defined$val;return 1 if$val eq $_}else {return 1 if not defined$val}}return 0}sub repl($) {my ($val)=@_;if (Scalar::Util::blessed($val)&& $val->can('__repl__')){$val->__repl__}elsif ((Scalar::Util::blessed($val)||'')eq 'boolean'){$val ? 'True' : 'False'}elsif (ref($val)eq 'ARRAY'){return '[' .join(', ',map {&repl($_)}@$val).']'}else {local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=1;Dumper($val)}}sub class_name {my$name=ref $_[0]|| $_[0];$name =~ s/^Docopt:://;$name}sub string_strip($) {local $_=shift;s/^\s+//;s/\s+$//;$_}sub string_partition($$) {my ($str,$sep)=@_;if ($str =~ /\A(.*?)$sep(.*)\z/s){return ($1,$sep,$2)}else {return ($str,'','')}}sub defined_or {defined($_[0])? $_[0]: $_[1]}1;
DOCOPT_UTIL

$fatpacked{"Exporter/Shiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_SHINY';
  package Exporter::Shiny;use 5.006001;use strict;use warnings;use Exporter::Tiny ();our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.044';sub import {my$me=shift;my$caller=caller;(my$nominal_file=$caller)=~ s(::)(/)g;$INC{"$nominal_file\.pm"}||= __FILE__;if (@_==2 and $_[0]eq -setup){my (undef,$opts)=@_;@_=@{delete($opts->{exports})|| []};if (%$opts){Exporter::Tiny::_croak('Unsupported Sub::Exporter-style options: %s',join(q[, ],sort keys %$opts),)}}ref($_)&& Exporter::Tiny::_croak('Expected sub name, got ref %s',$_)for @_;no strict qw(refs);push @{"$caller\::ISA"},'Exporter::Tiny';push @{"$caller\::EXPORT_OK"},@_}1;
EXPORTER_SHINY

$fatpacked{"Exporter/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXPORTER_TINY';
  package Exporter::Tiny;use 5.006001;use strict;use warnings;no warnings qw(void once uninitialized numeric redefine);our$AUTHORITY='cpan:TOBYINK';our$VERSION='0.044';our@EXPORT_OK=qw<mkopt mkopt_hash _croak _carp>;sub _croak ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::croak}sub _carp ($;@) {require Carp;my$fmt=shift;@_=sprintf($fmt,@_);goto \&Carp::carp}my$_process_optlist=sub {my$class=shift;my ($global_opts,$opts,$want,$not_want)=@_;while (@$opts){my$opt=shift @{$opts};my ($name,$value)=@$opt;($name =~ m{\A\!(/.+/[msixpodual]+)\z})? do {my@not=$class->_exporter_expand_regexp($1,$value,$global_opts);++$not_want->{$_->[0]}for@not}: ($name =~ m{\A\!(.+)\z})? (++$not_want->{$1}): ($name =~ m{\A[:-](.+)\z})? push(@$opts,$class->_exporter_expand_tag($1,$value,$global_opts)): ($name =~ m{\A/.+/[msixpodual]+\z})? push(@$opts,$class->_exporter_expand_regexp($name,$value,$global_opts)): push(@$want,$opt)}};sub import {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {no strict qw(refs);@_ ? @_ : @{"$class\::EXPORT"}};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_opts($global_opts);for my$wanted (@want){next if$not_want{$wanted->[0]};my%symbols=$class->_exporter_expand_sub(@$wanted,$global_opts,$permitted);$class->_exporter_install_sub($_,$wanted->[1],$global_opts,$symbols{$_})for keys%symbols}}sub unimport {my$class=shift;my$global_opts=+{@_ && ref($_[0])eq q(HASH) ? %{+shift}: ()};$global_opts->{into}=caller unless exists$global_opts->{into};$global_opts->{is_unimport}=1;my@want;my%not_want;$global_opts->{not}=\%not_want;my@args=do {our%TRACKED;@_ ? @_ : keys(%{$TRACKED{$class}{$global_opts->{into}}})};my$opts=mkopt(\@args);$class->$_process_optlist($global_opts,$opts,\@want,\%not_want);my$permitted=$class->_exporter_permitted_regexp($global_opts);$class->_exporter_validate_unimport_opts($global_opts);my$expando=$class->can('_exporter_expand_sub');$expando=undef if$expando==\&_exporter_expand_sub;for my$wanted (@want){next if$not_want{$wanted->[0]};if ($wanted->[1]){_carp("Passing options to unimport '%s' makes no sense",$wanted->[0])unless (ref($wanted->[1])eq 'HASH' and not keys %{$wanted->[1]})}my%symbols=defined($expando)? $class->$expando(@$wanted,$global_opts,$permitted): ($wanted->[0]=>sub {"dummy"});$class->_exporter_uninstall_sub($_,$wanted->[1],$global_opts)for keys%symbols}}sub _exporter_validate_opts {1}sub _exporter_validate_unimport_opts {1}sub _exporter_merge_opts {my$class=shift;my ($tag_opts,$global_opts,@stuff)=@_;$tag_opts={}unless ref($tag_opts)eq q(HASH);_croak('Cannot provide an -as option for tags')if exists$tag_opts->{-as}&& ref$tag_opts->{-as}ne 'CODE';my$optlist=mkopt(\@stuff);for my$export (@$optlist){next if defined($export->[1])&& ref($export->[1])ne q(HASH);my%sub_opts=(%{$export->[1]or {}},%$tag_opts);$sub_opts{-prefix}=sprintf('%s%s',$tag_opts->{-prefix},$export->[1]{-prefix})if exists($export->[1]{-prefix})&& exists($tag_opts->{-prefix});$sub_opts{-suffix}=sprintf('%s%s',$export->[1]{-suffix},$tag_opts->{-suffix})if exists($export->[1]{-suffix})&& exists($tag_opts->{-suffix});$export->[1]=\%sub_opts}return @$optlist}sub _exporter_expand_tag {no strict qw(refs);my$class=shift;my ($name,$value,$globals)=@_;my$tags=\%{"$class\::EXPORT_TAGS"};return$class->_exporter_merge_opts($value,$globals,$tags->{$name}->($class,@_))if ref($tags->{$name})eq q(CODE);return$class->_exporter_merge_opts($value,$globals,@{$tags->{$name}})if exists$tags->{$name};return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"})if$name eq 'all';return$class->_exporter_merge_opts($value,$globals,@{"$class\::EXPORT"})if$name eq 'default';$globals->{$name}=$value || 1;return}sub _exporter_expand_regexp {no strict qw(refs);our%TRACKED;my$class=shift;my ($name,$value,$globals)=@_;my$compiled=eval("qr$name");my@possible=$globals->{is_unimport}? keys(%{$TRACKED{$class}{$globals->{into}}}): @{"$class\::EXPORT_OK"};$class->_exporter_merge_opts($value,$globals,grep /$compiled/,@possible)}sub _exporter_permitted_regexp {no strict qw(refs);my$class=shift;my$re=join "|",map quotemeta,sort {length($b)<=> length($a)or $a cmp $b}@{"$class\::EXPORT"},@{"$class\::EXPORT_OK"};qr{^(?:$re)$}ms}sub _exporter_expand_sub {my$class=shift;my ($name,$value,$globals,$permitted)=@_;$permitted ||= $class->_exporter_permitted_regexp($globals);no strict qw(refs);if ($name =~ $permitted){my$generator=$class->can("_generate_$name");return$name=>$class->$generator($name,$value,$globals)if$generator;my$sub=$class->can($name);return$name=>$sub if$sub}$class->_exporter_fail(@_)}sub _exporter_fail {my$class=shift;my ($name,$value,$globals)=@_;return if$globals->{is_unimport};_croak("Could not find sub '%s' exported by %s",$name,$class)}sub _exporter_install_sub {my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};my$installer=$globals->{installer}|| $globals->{exporter};$name=ref$globals->{as}? $globals->{as}->($name): ref$value->{-as}? $value->{-as}->($name): exists$value->{-as}? $value->{-as}: $name;return unless defined$name;unless (ref($name)){my ($prefix)=grep defined,$value->{-prefix},$globals->{prefix},q();my ($suffix)=grep defined,$value->{-suffix},$globals->{suffix},q();$name="$prefix$name$suffix"}return ($$name=$sym)if ref($name)eq q(SCALAR);return ($into->{$name}=$sym)if ref($into)eq q(HASH);no strict qw(refs);if (exists &{"$into\::$name"}and \&{"$into\::$name"}!=$sym){my ($level)=grep defined,$value->{-replace},$globals->{replace},q(0);my$action={carp=>\&_carp,0=>\&_carp,''=>\&_carp,warn=>\&_carp,nonfatal=>\&_carp,croak=>\&_croak,fatal=>\&_croak,die=>\&_croak,}->{$level}|| sub {};$action->($action==\&_croak ? "Refusing to overwrite existing sub '%s::%s' with sub '%s' exported by %s" : "Overwriting existing sub '%s::%s' with sub '%s' exported by %s",$into,$name,$_[0],$class,)}our%TRACKED;$TRACKED{$class}{$into}{$name}=$sym;no warnings qw(prototype);$installer ? $installer->($globals,[$name,$sym]): (*{"$into\::$name"}=$sym)}sub _exporter_uninstall_sub {our%TRACKED;my$class=shift;my ($name,$value,$globals,$sym)=@_;my$into=$globals->{into};ref$into and return;no strict qw(refs);my$our_coderef=$TRACKED{$class}{$into}{$name};my$cur_coderef=exists(&{"$into\::$name"})? \&{"$into\::$name"}: -1;return unless$our_coderef==$cur_coderef;my$stash=\%{"$into\::"};my$old=delete$stash->{$name};my$full_name=join('::',$into,$name);for my$type (qw(SCALAR HASH ARRAY IO)){next unless defined(*{$old}{$type});*$full_name=*{$old}{$type}}delete$TRACKED{$class}{$into}{$name}}sub mkopt {my$in=shift or return [];my@out;$in=[map(($_=>ref($in->{$_})? $in->{$_}: ()),sort keys %$in)]if ref($in)eq q(HASH);for (my$i=0;$i < @$in;$i++){my$k=$in->[$i];my$v;($i==$#$in)? ($v=undef): !defined($in->[$i+1])? (++$i,($v=undef)): !ref($in->[$i+1])? ($v=undef): ($v=$in->[++$i]);push@out,[$k=>$v ]}\@out}sub mkopt_hash {my$in=shift or return;my%out=map +($_->[0]=>$_->[1]),@{mkopt($in)};\%out}1;
EXPORTER_TINY

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.008';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.026';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.011';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"List/MoreUtils.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS';
  package List::MoreUtils;use 5.008_001;use strict;use warnings;my$have_xs;BEGIN {our$VERSION='0.419';unless (defined($have_xs)){eval {require List::MoreUtils::XS}unless$ENV{LIST_MOREUTILS_PP};die $@ if $@ && defined$ENV{LIST_MOREUTILS_PP}&& $ENV{LIST_MOREUTILS_PP}==0;$have_xs=0+defined($INC{'List/MoreUtils/XS.pm'})}use List::MoreUtils::PP qw()}use Exporter::Tiny qw();my@junctions=qw(any all none notall);my@v0_22=qw(true false firstidx lastidx insert_after insert_after_string apply indexes after after_incl before before_incl firstval lastval each_array each_arrayref pairwise natatime mesh uniq minmax part _XScompiled);my@v0_24=qw(bsearch);my@v0_33=qw(sort_by nsort_by);my@v0_400=qw(one any_u all_u none_u notall_u one_u firstres onlyidx onlyval onlyres lastres singleton bsearchidx);my@all_functions=(@junctions,@v0_22,@v0_24,@v0_33,@v0_400);no strict "refs";if ($have_xs){my$x;for (@all_functions){List::MoreUtils->can($_)or *$_=$x if ($x=List::MoreUtils::XS->can($_))}}List::MoreUtils->can($_)or *$_=List::MoreUtils::PP->can($_)for (@all_functions);use strict;my%alias_list=(v0_22=>{first_index=>"firstidx",last_index=>"lastidx",first_value=>"firstval",last_value=>"lastval",zip=>"mesh",},v0_33=>{distinct=>"uniq",},v0_400=>{first_result=>"firstres",only_index=>"onlyidx",only_value=>"onlyval",only_result=>"onlyres",last_result=>"lastres",bsearch_index=>"bsearchidx",},);our@ISA=qw(Exporter::Tiny);our@EXPORT_OK=(@all_functions,map {keys %$_}values%alias_list);our%EXPORT_TAGS=(all=>\@EXPORT_OK,'like_0.22'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},none_u=>{-as=>'none'},notall_u=>{-as=>'notall'},@v0_22,keys %{$alias_list{v0_22}},],'like_0.24'=>[any_u=>{-as=>'any'},all_u=>{-as=>'all'},notall_u=>{-as=>'notall'},'none',@v0_22,@v0_24,keys %{$alias_list{v0_22}},],'like_0.33'=>[@junctions,@v0_22,@v0_33,keys %{$alias_list{v0_22}},keys %{$alias_list{v0_33}},],);for my$set (values%alias_list){for my$alias (keys %$set){no strict qw(refs);*$alias=__PACKAGE__->can($set->{$alias})}}1;
LIST_MOREUTILS

$fatpacked{"List/MoreUtils/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'LIST_MOREUTILS_PP';
  package List::MoreUtils::PP;use 5.008_001;use strict;use warnings;our$VERSION='0.419';sub any (&@) {my$f=shift;for (@_){return 1 if$f->()}return 0}sub all (&@) {my$f=shift;for (@_){return 0 unless$f->()}return 1}sub none (&@) {my$f=shift;for (@_){return 0 if$f->()}return 1}sub notall (&@) {my$f=shift;for (@_){return 1 unless$f->()}return 0}sub one (&@) {my$f=shift;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub any_u (&@) {my$f=shift;return if!@_;$f->()and return 1 foreach (@_);return 0}sub all_u (&@) {my$f=shift;return if!@_;$f->()or return 0 foreach (@_);return 1}sub none_u (&@) {my$f=shift;return if!@_;$f->()and return 0 foreach (@_);return 1}sub notall_u (&@) {my$f=shift;return if!@_;$f->()or return 1 foreach (@_);return 0}sub one_u (&@) {my$f=shift;return if!@_;my$found=0;for (@_){$f->()and $found++ and return 0}$found}sub true (&@) {my$f=shift;my$count=0;$f->()and ++$count foreach (@_);return$count}sub false (&@) {my$f=shift;my$count=0;$f->()or ++$count foreach (@_);return$count}sub firstidx (&@) {my$f=shift;for my$i (0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub firstval (&@) {my$test=shift;for (@_){return $_ if$test->()}return undef}sub firstres (&@) {my$test=shift;for (@_){my$testval=$test->();$testval and return$testval}return undef}sub onlyidx (&@) {my$f=shift;my$found;for my$i (0 .. $#_){local*_=\$_[$i];$f->()or next;defined$found and return -1;$found=$i}return defined$found ? $found : -1}sub onlyval (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){$test->()or next;$result=$_;$found++ and return undef}return$result}sub onlyres (&@) {my$test=shift;my$result=undef;my$found=0;for (@_){my$rv=$test->()or next;$result=$rv;$found++ and return undef}return$found ? $result : undef}sub lastidx (&@) {my$f=shift;for my$i (reverse 0 .. $#_){local*_=\$_[$i];return$i if$f->()}return -1}sub lastval (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return $_ if$testval}return undef}sub lastres (&@) {my$test=shift;my$ix;for ($ix=$#_;$ix >= 0;$ix-- ){local*_=\$_[$ix];my$testval=$test->();$_[$ix]=$_;return$testval if$testval}return undef}sub insert_after (&$\@) {my ($f,$val,$list)=@_;my$c=&firstidx($f,@$list);@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub insert_after_string ($$\@) {my ($string,$val,$list)=@_;my$c=firstidx {defined $_ and $string eq $_}@$list;@$list=(@{$list}[0 .. $c ],$val,@{$list}[$c + 1 .. $#$list ],)and return 1 if$c!=-1;return 0}sub apply (&@) {my$action=shift;&$action foreach my@values=@_;wantarray ? @values : $values[-1]}sub after (&@) {my$test=shift;my$started;my$lag;grep$started ||= do {my$x=$lag;$lag=$test->();$x},@_}sub after_incl (&@) {my$test=shift;my$started;grep$started ||= $test->(),@_}sub before (&@) {my$test=shift;my$more=1;grep$more &&=!$test->(),@_}sub before_incl (&@) {my$test=shift;my$more=1;my$lag=1;grep$more &&= do {my$x=$lag;$lag=!$test->();$x},@_}sub indexes (&@) {my$test=shift;grep {local*_=\$_[$_];$test->()}0 .. $#_}sub pairwise (&\@\@) {my$op=shift;use vars qw{@A @B};local (*A,*B)=@_;my ($caller_a,$caller_b)=do {my$pkg=caller();no strict 'refs';\*{$pkg .'::a'},\*{$pkg .'::b'}};my$limit=$#A > $#B ? $#A : $#B;local (*$caller_a,*$caller_b);map {(*$caller_a,*$caller_b)=\($A[$_],$B[$_]);$op->()}0 .. $limit}sub each_array (\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {return each_arrayref(@_)}sub each_arrayref {my@list=@_;my$index=0;my$max=0;for (@list){unless (ref $_ eq 'ARRAY'){require Carp;Carp::croak("each_arrayref: argument is not an array reference\n")}$max=@$_ if @$_ > $max}return sub {if (@_){my$method=shift;unless ($method eq 'index'){require Carp;Carp::croak("each_array: unknown argument '$method' passed to iterator.")}return undef if$index==0 || $index > $max;return$index - 1}return if$index >= $max;my$i=$index++;return map $_->[$i],@list}}sub natatime ($@) {my$n=shift;my@list=@_;return sub {return splice@list,0,$n}}sub mesh (\@\@;\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@\@) {my$max=-1;$max < $#$_ && ($max=$#$_)foreach @_;map {my$ix=$_;map $_->[$ix],@_}0 .. $max}sub uniq (@) {my%seen=();my$k;my$seen_undef;grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub singleton (@) {my%seen=();my$k;my$seen_undef;grep {1==(defined $_ ? $seen{$k=$_ }: $seen_undef)}grep {defined $_ ? not $seen{$k=$_ }++ : not $seen_undef++}@_}sub minmax (@) {return unless @_;my$min=my$max=$_[0];for (my$i=1;$i < @_;$i += 2 ){if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}if (@_ & 1){my$i=$#_;if ($_[$i - 1 ]<= $_[$i]){$min=$_[$i - 1 ]if$min > $_[$i - 1 ];$max=$_[$i]if$max < $_[$i]}else {$min=$_[$i]if$min > $_[$i];$max=$_[$i - 1 ]if$max < $_[$i - 1 ]}}return ($min,$max)}sub part (&@) {my ($code,@list)=@_;my@parts;push @{$parts[$code->($_)]},$_ foreach@list;return@parts}sub bsearch(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return;local*_=\$_[$k];$rc=$code->();$rc==0 and return wantarray ? $_ : 1;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return}sub bsearchidx(&@) {my$code=shift;my$rc;my$i=0;my$j=@_;do {my$k=int(($i + $j)/ 2);$k >= @_ and return -1;local*_=\$_[$k];$rc=$code->();$rc==0 and return$k;if ($rc < 0){$i=$k + 1}else {$j=$k - 1}}until$i > $j;return -1}sub sort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]cmp $b->[1]}map {[$_,scalar($code->())]}@list}sub nsort_by(&@) {my ($code,@list)=@_;return map {$_->[0]}sort {$a->[1]<=> $b->[1]}map {[$_,scalar($code->())]}@list}sub _XScompiled {0}1;
LIST_MOREUTILS_PP

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.014';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=$Test::Builder::Level - $REAL_CALCULATED_TBL;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(exception(\&$code),$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(!exception(\&$code),$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/TempDir/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TEMPDIR_TINY';
  use 5.006002;use strict;use warnings;package Test::TempDir::Tiny;our$VERSION='0.016';use Exporter 5.57 qw/import/;our@EXPORT=qw/tempdir in_tempdir/;use Carp qw/confess/;use Cwd qw/abs_path/;use Errno qw/EEXIST ENOENT/;{no warnings 'numeric';use File::Path 2.01 qw/remove_tree/}use File::Spec::Functions qw/catdir/;use File::Temp;my ($ROOT_DIR,$TEST_DIR,%COUNTER);my ($ORIGINAL_PID,$ORIGINAL_CWD,$TRIES,$DELAY,$SYSTEM_TEMP)=($$,abs_path("."),100,50 / 1000,0);sub _untaint {my$thing=shift;($thing)=$thing =~ /^(.*)$/;return$thing}sub tempdir {my$label=defined($_[0])? $_[0]: 'default';$label =~ tr{a-zA-Z0-9_-}{_}cs;_init()unless$ROOT_DIR && $TEST_DIR;my$suffix=++$COUNTER{$label};my$subdir=catdir($TEST_DIR,"${label}_${suffix}");mkdir _untaint($subdir)or confess("Couldn't create $subdir: $!");return$subdir}sub in_tempdir {my ($label,$code)=@_;my$wantarray=wantarray;my$cwd=abs_path(".");my$tempdir=tempdir($label);chdir$tempdir or die "Can't chdir to '$tempdir'";my (@ret);my$ok=eval {$code->($tempdir);1};my$err=$@;chdir$cwd or chdir "/" or die "Can't chdir to either '$cwd' or '/'";confess($err || "error from eval was lost")if!$ok;return}sub _inside_t_dir {-d "../t" && abs_path(".")eq abs_path("../t")}sub _init {my$DEFAULT_ROOT=catdir($ORIGINAL_CWD,"tmp");if (-d 't' && (-w $DEFAULT_ROOT || -w '.')){$ROOT_DIR=$DEFAULT_ROOT}elsif (_inside_t_dir()&& (-w '../$DEFAULT_ROOT' || -w '..')){$ROOT_DIR=catdir($ORIGINAL_CWD,"..","tmp")}else {$ROOT_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);$SYSTEM_TEMP=1}(my$dirname=$0)=~ tr{:\\/.}{_};$TEST_DIR=catdir($ROOT_DIR,$dirname);if (-d $TEST_DIR){remove_tree(_untaint($TEST_DIR),{safe=>0,keep_root=>1 });return}for my$n (1 .. $TRIES){if (!mkdir(_untaint($ROOT_DIR))){confess("Couldn't create $ROOT_DIR: $!")unless $!==EEXIST}$ROOT_DIR=abs_path($ROOT_DIR);if (mkdir _untaint($TEST_DIR)){$TEST_DIR=abs_path($TEST_DIR);return}if ($!!=ENOENT){confess("Couldn't create $TEST_DIR: $!")}if (-e $ROOT_DIR &&!-d _){confess("$ROOT_DIR is not a directory")}select(undef,undef,undef,$DELAY)if$n < $TRIES}warn "Couldn't create $TEST_DIR in $TRIES tries.\n" ."Using a regular tempdir instead.\n";$TEST_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);return}sub _cleanup {return if$ENV{PERL_TEST_TEMPDIR_TINY_NOCLEANUP};if ($ROOT_DIR && -d $ROOT_DIR){if ($SYSTEM_TEMP or not $?){chdir _untaint($ORIGINAL_CWD)or chdir "/" or warn "Can't chdir to '$ORIGINAL_CWD' or '/'. Cleanup might fail.";remove_tree(_untaint($TEST_DIR),{safe=>0 })if -d $TEST_DIR}rmdir _untaint($ROOT_DIR)unless -l $ROOT_DIR}}sub _root_dir {return$ROOT_DIR}END {if ($$==$ORIGINAL_PID){if ($] lt "5.008000"){*Test::TempDir::Tiny::_CLEANER::DESTROY=\&_cleanup;*blob=bless({},'Test::TempDir::Tiny::_CLEANER')}else {require B;push @{B::end_av()->object_2svref},\&_cleanup}}}1;
TEST_TEMPDIR_TINY

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.28';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}my$caller=caller;_subname("${caller}::try {...} "=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;my$caller=caller;_subname("${caller}::catch {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;my$caller=caller;_subname("${caller}::finally {...} "=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

$fatpacked{"boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'BOOLEAN';
  use strict;use warnings;package boolean;our$VERSION='0.46';my ($true,$false);use overload '""'=>sub {${$_[0]}},'!'=>sub {${$_[0]}? $false : $true},fallback=>1;use base 'Exporter';@boolean::EXPORT=qw(true false boolean);@boolean::EXPORT_OK=qw(isTrue isFalse isBoolean);%boolean::EXPORT_TAGS=(all=>[@boolean::EXPORT,@boolean::EXPORT_OK],test=>[qw(isTrue isFalse isBoolean)],);sub import {my@options=grep $_ ne '-truth',@_;$_[0]->truth if@options!=@_;@_=@options;goto&Exporter::import}my ($true_val,$false_val,$bool_vals);BEGIN {my$t=1;my$f=0;$true=do {bless \$t,'boolean'};$false=do {bless \$f,'boolean'};$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub CLONE {$true_val=overload::StrVal($true);$false_val=overload::StrVal($false);$bool_vals={$true_val=>1,$false_val=>1}}sub true() {$true}sub false() {$false}sub boolean($) {die "Not enough arguments for boolean::boolean" if scalar(@_)==0;die "Too many arguments for boolean::boolean" if scalar(@_)> 1;return not(defined $_[0])? false : "$_[0]" ? $true : $false}sub isTrue($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $true_val)? true : false}sub isFalse($) {not(defined $_[0])? false : (overload::StrVal($_[0])eq $false_val)? true : false}sub isBoolean($) {not(defined $_[0])? false : (exists$bool_vals->{overload::StrVal($_[0])})? true : false}sub truth {die "-truth not supported on Perl 5.22 or later" if $] >= 5.021005;&Internals::SvREADONLY(\!!0,0);&Internals::SvREADONLY(\!!1,0);${\!!0}=$false;${\!!1}=$true;&Internals::SvREADONLY(\!!0,1);&Internals::SvREADONLY(\!!1,1)}sub TO_JSON {${$_[0]}? \1 : \0}1;
BOOLEAN

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Carp qw(croak);
use Docopt;
use App::mimi;

my $opts = docopt();

my $command;
for (qw(check setup migrate fix set)) {
    if ($opts->{$_}) {
        $command = $_;
        last;
    }
}

App::mimi->new(
    dsn       => $opts->{'--dsn'},
    schema    => $opts->{'--schema'},
    dry_run   => $opts->{'--dry-run'},
    verbose   => $opts->{'--verbose'},
    setup     => $opts->{'--setup'},
    migration => $opts->{'<migration>'}
)->$command;

__END__

=pod

=head1 NAME

mimi - dbi migrations

=head1 SYNOPSIS

  mimi check   --dsn=<dsn>
  mimi migrate --dsn=<dsn> --schema=<directory> [--setup] [--verbose] [--dry-run]
  mimi setup   --dsn=<dsn> [--verbose] [--dry-run]
  mimi fix     --dsn=<dsn> [--verbose] [--dry-run]
  mimi set     --dsn=<dsn> <migration> [--verbose] [--dry-run]
  mimi -h | --help

  --dsn=<dsn>           DBI dsn string, 'dbi:SQLite:database.db' for example
  --schema=<directory>  Directory with migrations
  --dry-run             Do nothing, just show what's to be done
  --verbose             Be verbose
  -h --help             Show this screen.

=head1 DESCRIPTION

This is a migration script for small home projects. Despite of being small it's
still robust. This means that all the precautions are made to not to corrupt
your data.

=head2 Safety first

Every command has C<verbose> and C<dry-run> flags. Thus it is easy to check
first what's going to happen.

=head2 Check

    mimi check --dsn 'dbi:SQLite:database.db'

Check what's going on. Are migrations installed? What is the latest migration? Was there an error?

=head2 Setupping your database

    mimi setup --dsn 'dbi:SQLite:database.db'

This creates C<mimi> table in your database. This table is used as a journal for
migrations.

=head2 Migrations

    mimi migrate --dsn 'dbi:SQLite:database.db' --schema sql_files/

This will search C<sql_files> for C<*.sql> files, parse their names that usually
look like C<01add_column.sql>, C<02drop_table.sql> and so on. Then it will try
to find the last migration and run everything with a bigger number.

Using C<--setup> flag will setup migrations first if needed.

=head2 Failures and fixes

Failures do occur. Like you made a mistake in your migration (of course you
should run them on a local machine first!). C<mimi> will die but remember that
last migration was with error and won't let you run next migrations dying with:

    Error: Migrations are dirty. Last error was in migration 1:

        DBD::SQLite::db do failed: near "CREAT": syntax error

    After fixing the problem run <fix> command

After fixing the stuff, you either can C<fix> or C<set> the current migration
number manually:

    mimi fix --dsn '...'
    mimi set --dsn '...' 123

=head2 Additional checks

You will get descriptive errors when trying to do unexpected stuff, like running
migrations on a fresh database or supplying a directory without migration files.

=cut
